miniRT.h:
#ifndef MINIRT_H
# define MINIRT_H

# include <string.h>
# include "lib/libft/libft.h"
# include "gnl/get_next_line.h"
# include "mlx42-codam/include/MLX42/MLX42.h"
# include <unistd.h>
# include <stdio.h>
# include <stdlib.h>
# include <fcntl.h>
# define WIDTH 512
# define HEIGHT 512

extern mlx_image_t* image;

typedef struct s_color
{
	int	r;
	int	g;
	int	b;
}	t_color;

typedef struct s_ambient_lighting
{
	double		ratio;
	t_color		color;
}	t_amb_light;

typedef struct s_vec3
{
	double	x;
	double	y;
	double	z;
}	t_vec3;

typedef struct s_camera
{
	t_vec3 coord;
	t_vec3	orient;
	int		fov; //ยบ!!
}	t_camera;

typedef struct s_light
{
	t_vec3	coord;
	double	bright;
	//t_color	color;
}	t_light;

typedef struct s_sphere
{
	t_vec3	coord;
	double	diam;
	t_color	color;
}	t_sphere;

typedef struct s_plane
{
	t_vec3	coord;
	t_vec3	ori;
	t_color	color;
}	t_plane;

typedef struct s_cylinder
{
	t_vec3	coord;
	t_vec3	ori;
	double	diam;
	double	hgt;
	t_color	color;
}	t_cylinder;

typedef struct s_scene
{
	t_amb_light	ambient;
	t_camera	camera;
	t_light		light;
	int			has_light;
	t_sphere	*spheres;
	int			num_spheres;
	t_plane		*planes;
	int			num_planes;
	t_cylinder	*cylinders;
	int			num_cylinders;
}	t_scene;

void	init_scene(t_scene *scene);
int		init_ambient(char *line, t_scene *scene);
int		init_camera(char *line, t_scene *scene);
int		init_light(char *line, t_scene *scene);
int		init_sphere(char *line, t_scene *scene);
int		init_plane(char *line, t_scene *scene);
int		init_cylinder(char *line, t_scene *scene);

int		check_args(int argc, char *argv);
int		parse_rt_file(char *filename, t_scene *scene);
int		parse_color(char *str, t_color *color);
int		parse_vector(char *str, t_vec3 *vec, int is_vec);

int		ft_error(char *message);
void	free_split(char **split);
void	free_scene(t_scene *scene);
double	ft_atof(char *str);

#endif


free.c:
#include "miniRT.h"

void	free_split(char **split)
{
	int	i;

	if (!split)
		return ;
	i = 0;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

void	free_scene(t_scene *scene)
{
	if (scene->spheres)
		free(scene->spheres);
	if (scene->planes)
		free(scene->planes);
	if (scene->cylinders)
		free(scene->cylinders);
}

int	ft_error(char *message)
{
	write(2, "Error\n", 6);
	write(2, message, ft_strlen(message));
	write(2, "\n", 1);
	return (0);
}



main.c:
#include "miniRT.h"

// -----------------------------------------------------------------------------
// Codam Coding College, Amsterdam @ 2022-2023 by W2Wizard.
// See README in the root project for more information.
// -----------------------------------------------------------------------------

mlx_image_t* image;

int32_t ft_pixel(int32_t r, int32_t g, int32_t b, int32_t a)
{
    return (r << 24 | g << 16 | b << 8 | a);
}

void ft_randomize(void* param)
{
	(void)param;
	for (uint32_t i = 0; i < image->width; ++i)
	{
		for (uint32_t y = 0; y < image->height; ++y)
		{
			uint32_t color = ft_pixel(
				rand() % 0xFF, // R
				rand() % 0xFF, // G
				rand() % 0xFF, // B
				rand() % 0xFF  // A
			);
			mlx_put_pixel(image, i, y, color);
		}
	}
}

void ft_hook(void* param)
{
	mlx_t* mlx = param;

	if (mlx_is_key_down(mlx, MLX_KEY_ESCAPE))
		mlx_close_window(mlx);
	if (mlx_is_key_down(mlx, MLX_KEY_UP))
		image->instances[0].y -= 5;
	if (mlx_is_key_down(mlx, MLX_KEY_DOWN))
		image->instances[0].y += 5;
	if (mlx_is_key_down(mlx, MLX_KEY_LEFT))
		image->instances[0].x -= 5;
	if (mlx_is_key_down(mlx, MLX_KEY_RIGHT))
		image->instances[0].x += 5;
}

// -----------------------------------------------------------------------------

int32_t main(int argc, char **argv)
{
	mlx_t* mlx;
	t_scene	scene;

	if (!check_args(argc, argv[1]) || !parse_rt_file(argv[1], &scene))
		return (1);
	// Gotta error check this stuff
	if (!(mlx = mlx_init(WIDTH, HEIGHT, "MLX42", true)))
	{
		puts(mlx_strerror(mlx_errno));
		return(EXIT_FAILURE);
	}
	if (!(image = mlx_new_image(mlx, 128, 128)))
	{
		mlx_close_window(mlx);
		puts(mlx_strerror(mlx_errno));
		return(EXIT_FAILURE);
	}
	if (mlx_image_to_window(mlx, image, 0, 0) == -1)
	{
		mlx_close_window(mlx);
		puts(mlx_strerror(mlx_errno));
		return(EXIT_FAILURE);
	}
	
	mlx_loop_hook(mlx, ft_randomize, mlx);
	mlx_loop_hook(mlx, ft_hook, mlx);

	mlx_loop(mlx);
	mlx_terminate(mlx);
	free_scene(&scene);
	return (EXIT_SUCCESS);
}



parsing/init_elements.c:
#include "../miniRT.h"

int	init_ambient(char *line, t_scene *scene)
{
	char	**split;

	if (scene->ambient.ratio != -1.0)
		return (ft_error("Multiple ambient light definitions"));
	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1])
		return (ft_error("Invalid ambient light format"));
	scene->ambient.ratio = ft_atof(split[0]);
	if (!parse_color(split[1], &scene->ambient.color))
	{
		free_split(split);
		return (0);
	}
	free_split(split);
	return (1);
}

int	init_camera(char *line, t_scene *scene)
{
	char	**split;

	if (scene->camera.fov != -1)
		return (ft_error("Multiple camera definitions"));
	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1] || !split[2])
		return (ft_error("Invalid camera format"));
	if (!parse_vector(split[0], &scene->camera.coord, 0)
		|| !parse_vector(split[1], &scene->camera.orient, 1))
	{
		free_split(split);
		return (0);
	}
	scene->camera.fov = ft_atoi(split[2]);
	free_split(split);
	return (1);
}

int	init_light(char *line, t_scene *scene)
{
	char	**split;

	if (scene->has_light)
		return (ft_error("Multiple light definitions"));
	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1])
		return (ft_error("Invalid light format"));
	if (!parse_vector(split[0], &scene->light.coord, 0))
	{
		free_split(split);
		return (0);
	}
	scene->light.bright = ft_atof(split[1]);
	scene->has_light = 1;
	free_split(split);
	return (1);
}



parsing/init_objects.c:
#include "../miniRT.h"

static void	*realloc_array(
	void *old, size_t old_count, size_t new_count, size_t elem_size)
{
	void	*new_array;

	new_array = malloc(elem_size * new_count);
	if (!new_array)
		return (NULL);
	if (old)
	{
		ft_memcpy(new_array, old, elem_size * old_count);
		free(old);
	}
	return (new_array);
}

int	init_sphere(char *line, t_scene *scene)
{
	char		**split;
	t_sphere	*new_spheres;

	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1] || !split[2])
		return (0);
	new_spheres = realloc_array(scene->spheres, scene->num_spheres,
			scene->num_spheres + 1, sizeof(t_sphere));
	if (!new_spheres)
		return (0);
	new_spheres[scene->num_spheres].diam = ft_atof(split[1]);
	if (!parse_vector(split[0], &new_spheres[scene->num_spheres].coord, 0)
		|| !parse_color(split[2], &new_spheres[scene->num_spheres].color))
		return (0);
	scene->spheres = new_spheres;
	scene->num_spheres++;
	free_split(split);
	return (1);
}

int	init_plane(char *line, t_scene *scene)
{
	char	**split;
	t_plane	*new_planes;
	t_plane	*pl;

	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1] || !split[2])
		return (ft_error("Invalid plane format"));
	new_planes = realloc_array(scene->planes, scene->num_planes,
			scene->num_planes + 1, sizeof(t_plane));
	if (!new_planes)
		return (0);
	pl = &new_planes[scene->num_planes];
	if (!parse_vector(split[0], &pl->coord, 0)
		|| !parse_vector(split[1], &pl->ori, 1)
		|| !parse_color(split[2], &pl->color))
		return (0);
	scene->planes = new_planes;
	scene->num_planes++;
	free_split(split);
	return (1);
}

int	init_cylinder(char *line, t_scene *scene)
{
	char		**split;
	t_cylinder	*new_cylinders;
	t_cylinder	*cy;

	split = ft_split(line, ' ');
	if (!split || !split[0] || !split[1] || !split[2] || !split[3] || !split[4])
		return (ft_error("Invalid cylinder format"));
	new_cylinders = realloc_array(scene->cylinders, scene->num_cylinders,
			scene->num_cylinders + 1, sizeof(t_cylinder));
	if (!new_cylinders)
		return (0);
	cy = &new_cylinders[scene->num_cylinders];
	if (!parse_vector(split[0], &cy->coord, 0)
		|| !parse_vector(split[1], &cy->ori, 1))
		return (0);
	cy->diam = ft_atof(split[2]);
	cy->hgt = ft_atof(split[3]);
	if (!parse_color(split[4], &cy->color))
		return (0);
	scene->cylinders = new_cylinders;
	scene->num_cylinders++;
	free_split(split);
	return (1);
}



parsing/init_parse_rt.c:
#include "../miniRT.h"

static int	validate_scene(t_scene *scene)
{
	if (scene->ambient.ratio == -1.0)
		return (ft_error("Missing ambient light definition"));
	if (scene->camera.fov == -1)
		return (ft_error("Missing camera definition"));
	if (!scene->has_light)
		return (ft_error("Missing light definition"));
	if (scene->ambient.ratio < 0.0 || scene->ambient.ratio > 1.0)
		return (ft_error("Ambient ratio must be between 0.0 and 1.0"));
	if (scene->camera.fov < 0 || scene->camera.fov > 180)
		return (ft_error("Camera FOV must be between 0 and 180"));
	return (1);
}

static int	parse_line(char *line, t_scene *scene)
{
	if (!line || !*line || *line == '\n')
		return (1);
	if (line[0] == 'A' && line[1] == ' ')
		return (init_ambient(line + 2, scene));
	else if (line[0] == 'C' && line[1] == ' ')
		return (init_camera(line + 2, scene));
	else if (line[0] == 'L' && line[1] == ' ')
		return (init_light(line + 2, scene));
	else if (line[0] == 's' && line[1] == 'p' && line[2] == ' ')
		return (init_sphere(line + 3, scene));
	else if (line[0] == 'p' && line[1] == 'l' && line[2] == ' ')
		return (init_plane(line + 3, scene));
	else if (line[0] == 'c' && line[1] == 'y' && line[2] == ' ')
		return (init_cylinder(line + 3, scene));
	else
		return (ft_error("Unknown element type"));
}

int	parse_rt_file(char *filename, t_scene *scene)
{
	int		fd;
	char	*line;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (ft_error("Cannot open file"));
	init_scene(scene);
	line = get_next_line(fd);
	while (line != NULL)
	{
		if (!parse_line(line, scene))
		{
			free(line);
			close(fd);
			return (0);
		}
		free(line);
		line = get_next_line(fd);
	}
	close(fd);
	return (validate_scene(scene));
}

int	check_args(int argc, char *argv)
{
	int		len;

	if (argc != 2)
		return (ft_error("Usage: ./miniRT <scene.rt>"));
	len = 0;
	while (argv[len])
		len++;
	if (len < 3)
		return (ft_error("Invalid file name"));
	if (argv[len - 3] != '.' || argv[len - 2] != 'r' || argv[len - 1] != 't')
		return (ft_error("File must have .rt extension"));
	return (1);
}


parsing/parse_utils.c:
#include "../miniRT.h"

void	init_scene(t_scene *scene)
{
	scene->ambient.ratio = -1.0;
	scene->ambient.color = (t_color){0, 0, 0};
	scene->camera.coord = (t_vec3){0, 0, 0};
	scene->camera.orient = (t_vec3){0, 0, 0};
	scene->camera.fov = -1;
	scene->light.coord = (t_vec3){0, 0, 0};
	scene->light.bright = 0.0;
	scene->has_light = 0;
	scene->spheres = NULL;
	scene->num_spheres = 0;
	scene->planes = NULL;
	scene->num_planes = 0;
	scene->cylinders = NULL;
	scene->num_cylinders = 0;
}

int	parse_vector(char *str, t_vec3 *vec, int is_vec)
{
	char	**split;
	float	x;
	float	y;
	float	z;

	split = ft_split(str, ',');
	if (!split || !split[0] || !split[1] || !split[2] || split[3])
	{
		free_split(split);
		return (ft_error("Invalid vector format"));
	}
	x = ft_atof(split[0]);
	y = ft_atof(split[1]);
	z = ft_atof(split[2]);
	free_split(split);
	if (is_vec
		&& (x < -1.0 || x > 1.0 || y < -1.0 || y > 1.0 || z < -1.0 || z > 1.0))
		return (ft_error("Vector component out of range [-1,1]"));
	vec->x = x;
	vec->y = y;
	vec->z = z;
	return (1);
}

int	parse_color(char *str, t_color *color)
{
	char	**split;
	int		r;
	int		g;
	int		b;

	split = ft_split(str, ',');
	if (!split || !split[0] || !split[1] || !split[2] || split[3])
	{
		free_split(split);
		return (ft_error("Invalid RGB format"));
	}
	r = ft_atoi(split[0]);
	g = ft_atoi(split[1]);
	b = ft_atoi(split[2]);
	free_split(split);
	if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255)
		return (ft_error("RGB value out of range (0-255)"));
	color->r = r;
	color->g = g;
	color->b = b;
	return (1);
}

double	ft_atof(char *str)
{
	double	result;
	double	fraction;
	int		sign;

	result = 0.0;
	fraction = 0.1;
	sign = 1;
	if (*str == '-' && ++str)
		sign = -1;
	while (*str >= '0' && *str <= '9')
	{
		result = result * 10.0 + (*str - '0');
		str++;
	}
	if (*str == '.')
	{
		str++;
		while (*str >= '0' && *str <= '9')
		{
			result += (*str - '0') * fraction;
			fraction /= 10.0;
			str++;
		}
	}
	return (result * sign);
}



